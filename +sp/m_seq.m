%--------------------------------------------------------------------------
%   [list] = m_seq(coef)
%--------------------------------------------------------------------------
%   功能：
%   m序列生成器，常用于生成伪随机序列，可以与RS编码组合使用进行抗干扰处理
%--------------------------------------------------------------------------
%   输入：
%           coef            输入反馈连接线
%   输出：
%           list            反馈循环系数
%--------------------------------------------------------------------------
%   m序列反馈系数表
%--------------------------------------------------------------------------
%   级数N     周期P         反馈系数(八进制)
%--------------------------------------------------------------------------
%   3           7           13
%   4           15          23
%   5           31          45 67 75
%   6           63          103 147 155
%   7           127         203 211 217 235 277 313 325 345
%   8           255         435 453 537 543 545 551 703 747
%   9           511         1021 1055 1131 1157 1167 1175
%   10          1023        2011 2033 2157 2443 2745 3471
%   11          2047        4005 4445 5023 5263 6211 7363
%   12          4095        10123 11417 12515 13505 14127 15053
%   13          8191        20033 23261 24633 30741 32535 37505
%   14          16383       42103 51761 55753 60153 71147 67401
%   15          32765       10003 110013 120265 133663 142305
%--------------------------------------------------------------------------
%   例子：
%--------------------------------------------------------------------------
%   fliplr(dec2bin(oct2dec(13)))        %多项式反馈系数
%   sp.mseq(13)
%--------------------------------------------------------------------------
function [list,seq] = m_seq(coef)
coef = b2array(fliplr(dec2bin(oct2dec(coef))));
disp(['反馈系数:' num2str(coef)])
m = length(coef);               
len = 2^(m-1);                                                              %得到最终生成的m序列的长度
backQ = [];                                                                  %对应寄存器运算后的值，放在第一个寄存器
seq = zeros(1, len);                                                        %给生成的m序列预分配
registers = [1 zeros(1,m-2) 1];                                             %给寄存器分配初始结果

for idx = 1:len-1
    seq(idx) = registers(m);
    backQ = mod(sum(coef .* registers),2);                                  %特定寄存器的值进行异或运算，模2加
    registers(2:length(registers)) = registers(1:length(registers)-1);
    registers(1) = backQ;
    list(idx,:) = registers(1:end-1);
end
end


function bin_array = b2array(str)
bin_array = logical(str2num(char(str)')');
end